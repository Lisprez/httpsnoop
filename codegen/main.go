package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"strings"
)

func main() {
	interfaces := []string{
		"http.Flusher",
		"http.Hijacker",
		"http.CloseNotifier",
		"io.ReaderFrom",
	}
	var g Generator
	g.Printf("// Code generated by \"httpsnoop/codegen\"; DO NOT EDIT\n")
	g.Printf("\n")
	g.Printf("package httpsnoop\n")
	g.Printf("import (\n")
	g.Printf(`"net/http"` + "\n")
	g.Printf(`"io"` + "\n")
	g.Printf(")\n")
	docList := make([]string, len(interfaces))
	for i, iname := range interfaces {
		docList[i] = "// - " + iname
	}
	g.Printf(`
// Wrap returns a wrapped version of w that provides the exact same interface
// as w. Specifically if w implements any combination of:
// 
%s
//
// The wrapped version will implement the exact same combination. If no hooks
// are set, the wrapped version also behaves exactly as w. Hooks targeting
// methods not supported by w are ignored. Any other hooks will intercept the
// method they target and may modify the call's arguments and/or return values.
// The CaptureMetrics implementation serves as a working example for how the
// hooks can be used.
`, strings.Join(docList, "\n"))
	g.Printf("func Wrap(w http.ResponseWriter, hooks Hooks) http.ResponseWriter {\n")
	g.Printf("rw := &rw{w: w, h: hooks}\n")
	for i, iname := range interfaces {
		g.Printf("_, i%d := w.(%s)\n", i, iname)
	}
	g.Printf("switch {\n")
	for i := 0; i < 1<<uint(len(interfaces)); i++ {
		conditions := make([]string, len(interfaces))
		fields := make([]string, 0, len(interfaces))
		fields = append(fields, "http.ResponseWriter")
		for j, iname := range interfaces {
			ok := i&(1<<uint(len(interfaces)-j-1)) > 0
			if !ok {
				conditions[j] = "!"
			} else {
				fields = append(fields, iname)
			}
			conditions[j] += fmt.Sprintf("i%d", j)
		}
		values := make([]string, len(fields))
		for i, _ := range fields {
			values[i] = "rw"
		}
		g.Printf("case %s:\n", strings.Join(conditions, "&&"))
		fieldsS, valuesS := strings.Join(fields, "\n"), strings.Join(values, ",")
		g.Printf("return struct{\n%s\n}{%s}\n", fieldsS, valuesS)
	}
	g.Printf("}\n")
	g.Printf("panic(\"unreachable\")")
	g.Printf("}\n")
	src, err := g.Format()
	if err != nil {
		fatalf("format: %s:\n\n%s", err, g.Bytes())
	}
	fmt.Printf("%s\n", src)
}

type Generator struct {
	buf bytes.Buffer
}

func (g *Generator) Printf(s string, args ...interface{}) {
	fmt.Fprintf(&g.buf, s, args...)
}

func (g *Generator) Bytes() []byte {
	return g.buf.Bytes()
}

func (g *Generator) Format() ([]byte, error) {
	return format.Source(g.Bytes())
}

func fatalf(s string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, s+"\n", args...)
	os.Exit(1)
}
