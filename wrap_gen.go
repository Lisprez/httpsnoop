// Code generated by "httpsnoop/codegen"; DO NOT EDIT

package httpsnoop

import (
	"io"
	"net/http"
)

// Wrap returns a wrapped version of w that provides the exact same interface
// as w. Specifically if w implements any combination of:
//
// - http.Flusher
// - http.Hijacker
// - http.CloseNotifier
// - io.ReaderFrom
//
// The wrapped version will implement the exact same combination. If no hooks
// are set, the wrapped version also behaves exactly as w. Hooks targeting
// methods not supported by w are ignored. Any other hooks will intercept the
// method they target and may modify the call's arguments and/or return values.
// The CaptureMetrics implementation serves as a working example for how the
// hooks can be used.
func Wrap(w http.ResponseWriter, hooks Hooks) http.ResponseWriter {
	rw := &rw{w: w, h: hooks}
	_, i0 := w.(http.Flusher)
	_, i1 := w.(http.Hijacker)
	_, i2 := w.(http.CloseNotifier)
	_, i3 := w.(io.ReaderFrom)
	switch {
	case !i0 && !i1 && !i2 && !i3:
		return struct {
			http.ResponseWriter
		}{rw}
	case !i0 && !i1 && !i2 && i3:
		return struct {
			http.ResponseWriter
			io.ReaderFrom
		}{rw, rw}
	case !i0 && !i1 && i2 && !i3:
		return struct {
			http.ResponseWriter
			http.CloseNotifier
		}{rw, rw}
	case !i0 && !i1 && i2 && i3:
		return struct {
			http.ResponseWriter
			http.CloseNotifier
			io.ReaderFrom
		}{rw, rw, rw}
	case !i0 && i1 && !i2 && !i3:
		return struct {
			http.ResponseWriter
			http.Hijacker
		}{rw, rw}
	case !i0 && i1 && !i2 && i3:
		return struct {
			http.ResponseWriter
			http.Hijacker
			io.ReaderFrom
		}{rw, rw, rw}
	case !i0 && i1 && i2 && !i3:
		return struct {
			http.ResponseWriter
			http.Hijacker
			http.CloseNotifier
		}{rw, rw, rw}
	case !i0 && i1 && i2 && i3:
		return struct {
			http.ResponseWriter
			http.Hijacker
			http.CloseNotifier
			io.ReaderFrom
		}{rw, rw, rw, rw}
	case i0 && !i1 && !i2 && !i3:
		return struct {
			http.ResponseWriter
			http.Flusher
		}{rw, rw}
	case i0 && !i1 && !i2 && i3:
		return struct {
			http.ResponseWriter
			http.Flusher
			io.ReaderFrom
		}{rw, rw, rw}
	case i0 && !i1 && i2 && !i3:
		return struct {
			http.ResponseWriter
			http.Flusher
			http.CloseNotifier
		}{rw, rw, rw}
	case i0 && !i1 && i2 && i3:
		return struct {
			http.ResponseWriter
			http.Flusher
			http.CloseNotifier
			io.ReaderFrom
		}{rw, rw, rw, rw}
	case i0 && i1 && !i2 && !i3:
		return struct {
			http.ResponseWriter
			http.Flusher
			http.Hijacker
		}{rw, rw, rw}
	case i0 && i1 && !i2 && i3:
		return struct {
			http.ResponseWriter
			http.Flusher
			http.Hijacker
			io.ReaderFrom
		}{rw, rw, rw, rw}
	case i0 && i1 && i2 && !i3:
		return struct {
			http.ResponseWriter
			http.Flusher
			http.Hijacker
			http.CloseNotifier
		}{rw, rw, rw, rw}
	case i0 && i1 && i2 && i3:
		return struct {
			http.ResponseWriter
			http.Flusher
			http.Hijacker
			http.CloseNotifier
			io.ReaderFrom
		}{rw, rw, rw, rw, rw}
	}
	panic("unreachable")
}

